Java内存模型即Java Memory Model，简称JMM。JMM定义了Java 虚拟机(JVM)在计算机内存(RAM)中的工作方式。
Java内存模型定义了多线程之间共享变量的可见性以及如何在需要的时候对共享变量进行同步

线程之间的通信机制有两种共享内存（共享对象）和消息传递（wait()和notify()）。

线程之间的同步
同步是指程序用于控制不同线程之间操作发生相对顺序的机制。

在共享内存并发模型里，同步是显式进行的。程序员必须显式指定某个方法或某段代码需要在线程之间互斥执行。

在消息传递的并发模型里，由于消息的发送必须在消息的接收之前，因此同步是隐式进行的。

Java的并发采用的是共享内存模型
Java线程之间的通信总是隐式进行，整个通信过程对程序员完全透明。如果编写多线程程序的Java程序员不理解隐式进行的线程之间通信的工作机制，很可能会遇到各种奇怪的内存可见性问题。

volatile和synchronized的区别
volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取； synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。
volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的
volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性
volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。
volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化



JVM结构
1.类加载器（ClassLoader）:在JVM启动时或者在类运行时将需要的class加载到JVM中。
	BootStrapClassLoader，（JVM启动时初始化，它主要用来读取Java的核心类库JRE/lib/rt.jar中所有的class文件）
ExtensionClassLoader，（它是用来读取Java的一些扩展类库，如读取JRE/lib/ext/*.jar中的包等）
AppClassLoader，（默认的类加载器）
CustomClassLoader（用户自定义编写的）

2.执行引擎：负责执行class文件中包含的字节码指令
3.内存区（也叫运行时数据区）：是在JVM运行的时候操作所分配的内存区。运行时内存区主要可以划分为5个区域，
•	方法区(Method Area)：用于存储类结构信息的地方，包括常量池、静态变量、构造函数等。虽然JVM规范把方法区描述为堆的一个逻辑部分， 但它却有个别名non-heap（非堆），所以大家不要搞混淆了。方法区还包含一个运行时常量池。
•	java堆(Heap)：存储java实例或者对象的地方。这块是GC的主要区域（后面解释）。从存储的内容我们可以很容易知道，方法区和堆是被所有java线程共享的。
o	java垃圾回收
o	年轻代：是所有新对象产生的地方。年轻代被分为3个部分——Enden区和两个Survivor区（From和to）当Eden区被对象填满时，就会执行Minor GC。并把所有存活下来的对象转移到其中一个survivor区（假设为from区）。Minor GC同样会检查存活下来的对象，并把它们转移到另一个survivor区（假设为to区）。这样在一段时间内，总会有一个空的survivor区。经过多次GC周期后，仍然存活下来的对象会被转移到年老代内存空间。通常这是在年轻代有资格提升到年老代前通过设定年龄阈值来完成的。需要注意，Survivor的两个区是对称的，没先后关系，from和to是相对的。
o	年老代：在年轻代中经历了N次回收后仍然没有被清除的对象，就会被放到年老代中，可以说他们都是久经沙场而不亡的一代，都是生命周期较长的对象。对于年老代和永久代，就不能再采用像年轻代中那样搬移腾挪的回收算法，因为那些对于这些回收战场上的老兵来说是小儿科。通常会在老年代内存被占满时将会触发Full GC,回收整个堆内存。
o	持久代：用于存放静态文件，比如java类、方法等。持久代对垃圾回收没有显著的影响。 （方法区(Method Area)）
•	java栈(Stack)：java栈总是和线程关联在一起，每当创建一个线程时，JVM就会为这个线程创建一个对应的java栈。在这个java栈中又会包含多个栈帧，每运行一个方法就创建一个栈帧，用于存储局部变量表、操作栈、方法返回值等。每一个方法从调用直至执行完成的过程，就对应一个栈帧在java栈中入栈到出栈的过程。所以java栈是现成私有的。
•	程序计数器(PC Register)：用于保存当前线程执行的内存地址。由于JVM程序是多线程执行的（线程轮流切换），所以为了保证线程切换回来后，还能恢复到原先状态，就需要一个独立的计数器，记录之前中断的地方，可见程序计数器也是线程私有的。
•	本地方法栈(Native Method Stack)：和java栈的作用差不多，只不过是为JVM使用到的native方法服务的。



JAVA内存模型
共享内存模型
	
支撑Java内存模型的基础原理
•	指令重排序
•	数据依赖性
		如果两个操作访问同一个变量，其中一个为写操作，此时这两个操作之间存在数据依赖性。 
		编译器和处理器不会改变存在数据依赖性关系的两个操作的执行顺序，即不会重排序。
•	as-if-serial
		不管怎么重排序，单线程下的执行结果不能被改变，编译器、runtime和处理器都必须遵守as-if-serial语义。
•	内存屏障（Memory Barrier ）
		上面讲到了，通过内存屏障可以禁止特定类型处理器的重排序，从而让程序按我们预想的流程去执行。内存屏障，又称内存栅栏，是一个CPU指令，基本上它是一条这样的指令：
		1.	保证特定操作的执行顺序。
		2.	影响某些数据（或则是某条指令的执行结果）的内存可见性。


volatile和synchronization


JVM结构
	-类加载器
		bootstarpClassload，jvm启动时加载java核心类库
		extensionClassload, 加载java扩展类库
		appClassload,默认类加载器
		customerClassload,用户自定义类加载器
	-执行引擎
		执行class字节码文件
	-内存区
		方法区 ，存储类结构，常量池，静态变量
		堆，存储对象
		栈，存储局部变量，线程栈区
		程序计数器，保存线程执行的内存地址
		本地方法区，jvm本地方法，C语言执行
