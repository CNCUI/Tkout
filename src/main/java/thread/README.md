1.竞争条件
2.死锁
3.volatile，memory barrier(内存屏障)
4.JVM的内存模型
5.Condition Variable，spin lock
6.Executor
7.wait notify
8.读写锁（Reader/Writer Lock，非常经典的范式，有偏向读和写的不同变形，至少被要求写过3次）
9.生产消费范式（写过2次）
10.一些常用容器的实现，比如BlockingQueue（写过3次）或者concurrentHashmap（写过2次）



1.
竞争条件指多个线程或者进程在读写一个共享数据时结果依赖于它们执行的相对时间的情形。
竞争条件发生在当多个进程或者线程在读写数据时，其最终的的结果依赖于多个进程的指令执行顺序。
例如：考虑下面的例子
假设两个进程P1和P2共享了变量a。在某一执行时刻，P1更新a为1，在另一时刻，P2更新a为2。
因此两个任务竞争地写变量a。在这个例子中，竞争的“失败者”(最后更新的进程）决定了变量a的最终值。
多个进程并发访问和操作同一数据且执行结果与访问的特定顺序有关，称为竞争条件。


2.
死锁的发生必须具备以下四个必要条件
1）互斥条件：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。
2）请求和保持条件：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。
3）不剥夺条件：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。
4）环路等待条件：指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。
预防：只要打破四个必要条件之一就能有效预防死锁的发生，银行家算法
